#!/usr/bin/env bash

show_help() {
cat >&2 <<EOF
Usage: sshrc [OPTIONS] SSH_ARGS...
Description: Carry your dotfiles with you.

Options:
  --arg-max=BYTES     Ensure SSH_CMD is less than BYTES in size;
                      SSH_CMD is comprised of the compressed sshrc bootstrap
                      script, including .sshrc and the contents of .sshrc.d
  -h, --help          Display this help message and exit

SSH arguments:
  see ssh(1)
EOF
}

# Use openssl or base64
encode() {
  if  [ "$(command -v openssl)" ]; then openssl enc -base64 "$@"
  elif [ "$(command -v base64)" ]; then base64 "$@"
  fi
}

# Remove empty lines and full line comments
minify() {
  echo "$1"| sed '/^\s*$/d; /^\s*#[^!]/d'
}

# Ensure ssh_cmd will be less than 64kb
check_size() {
  local LC_ALL=C size="${#1}"

  [[ "${ARG_MAX}" == 0 ]] && return
  if [[ "${size}" -gt "${ARG_MAX:=$(( 65 * 1024 ))}" ]]; then
    echo >&2 "Error: the compressed size of .sshrc, .sshrc.d, and the sshrc" \
      "script is greater than 64kb"
    echo >&2 "Current size: ${size} bytes"
    exit 1
  fi
}

sshrc_cmd() {
  local files welcome rc bootstrap

  if [[ -f "${SSHHOME}/.sshrc" ]]; then
    files="${files} .sshrc"
  else
    echo >&2 "Error: could not find .sshrc in current directory or ${HOME}"
    exit 1
  fi
  [[ -d "${SSHHOME}/.sshrc.d" ]] && files="${files} .sshrc.d"

  if [[ "$#" -le 1 && ! -e "${SSHHOME}/.sshrc.d/.hushlogin" ]]; then
    welcome="[ ! -e \"\$HOME/.hushlogin\" -a -e /etc/motd ] && cat /etc/motd"
  else
    welcome=""
  fi

  rc="
  [[ -r /etc/profile ]] && source /etc/profile
  if [[ -r ~/.bash_profile ]]; then
    source ~/.bash_profile
  elif [[ -r ~/.bash_login ]]; then
    source ~/.bash_login
  elif [[ -r ~/.profile ]]; then
    source ~/.profile
  fi
  export PATH=\$PATH:\$SSHHOME
  source \$SSHHOME/.sshrc"

  bootstrap="
  # Copy .sshrc and .sshrc.d; clean up when leaving
  export SSHHOME=\$(mktemp -d -t .$(whoami).sshrc.XXXXXXXX)
  export SSHRCCLEANUP=\$SSHHOME
  trap \"rm -rf \$SSHRCCLEANUP; exit\" 0
  echo $'$(tar c -h -C "${SSHHOME}" ${files} | openssl enc -base64)' \
    | openssl enc -base64 -d \
    | tar mx -C \$SSHHOME

  # Copy sshrc binary, so we can run sshrc again from the new host
  echo $'$(minify "$(cat "$0")" | openssl enc -base64)' \
    | openssl enc -base64 -d > \$SSHHOME/sshrc
  chmod +x \$SSHHOME/sshrc

  # Create a wrapper around bash and use that as the shell
  echo 'bash --rcfile <(echo \"${rc}\") \"\$@\"' > \$SSHHOME/sshrcsh
  chmod +x \$SSHHOME/sshrcsh
  SHELL=\$SSHHOME/sshrcsh
  $welcome
  \$SSHHOME/sshrcsh $([[ "$#" -gt 1 ]] && echo "-c \"$*\"")"

  minify "
  # Bail if openssl isn't installed on the remote host
  $(declare -f encode)
  if [ ! \$(command -v encode) ]; then
    echo >&2 \"Error: sshrc requires openssl or base64 to be installed \" \\
      \"on the server\"
    exit 1
  fi

  # Compress bootstrap script for faster initial ssh connection and reduced
  # risk of hitting command buffer length limit
  eval \"\$(echo $'$(echo "${bootstrap}" | gzip -c | openssl enc -base64)' \
    | openssl enc -base64 -d \
    | gzip -d)\""
}

main() {
  local ssh_args host sshrc_cmd cmd size
  while getopts ":h-:b:c:D:E:e:F:I:i:J:L:l:m:O:o:p:Q:R:S:W:w:" opt; do
    case "${opt}" in
      -)
        case "${OPTARG}" in
          help)
            show_help
            exit 0
            ;;
          arg-max)
            ARG_MAX="${!OPTIND}"
            OPTIND=$(( OPTIND + 1 ))
            ;;
          arg-max=*)
            ARG_MAX="${OPTARG#*=}"
            ;;
          *)
            if [ "$OPTERR" = 1 ]; then
              echo "Invalid option --${OPTARG}" >&2
            fi
            ;;
        esac;;
      b|c|D|E|e|F|I|i|J|L|l|m|O|o|p|Q|R|S|W|w)
        ssh_args="${ssh_args} -${opt} -${OPTARG}"
        ;;
      h)
        show_help
        exit 0
        ;;
      *)
        ssh_args="${ssh_args} -${OPTARG}"
        ;;
    esac
  done
  shift $((OPTIND-1))
  host="$1"
  shift
  cmd="$*"

  if [[ ! $(command -v encode) ]]; then
    echo >&2 "Error: sshrc requires openssl or base64 to be installed locally"
    exit 1
  fi

  if [[ -z "${SSHHOME}" ]]; then
    for SSHHOME in $PWD $HOME; do
      [[ -f "${SSHHOME}/.sshrc" ]] && break
    done
  fi

  sshrc_cmd="$(sshrc_cmd "$cmd")"
  check_size "${sshrc_cmd}"

  #echo "${sshrc_cmd}"
  ssh -t ${ssh_args} "${host}" "${sshrc_cmd}"
}

main "$@"
