#!/usr/bin/env bash

show_help() {
cat >&2 <<EOF
Usage: sshrc [OPTIONS] [SSH_ARGS...]

Options:
  --archiver=UTILITY  Use UTILITY for compression
                      Default is bzip2; gzip and xz are also supported
  --arg-max=BYTES     Ensure SSHRC_CMD is less than BYTES in size
                      Default is 65536 (64kb); set to 0 to disable this check
  --arg-size          Print the compressed size of SSHRC_CMD in bytes and exit
  --hushlogin         Supress motd welcome messages
                      This can also be accomplished by creating a .hushlogin
                      file ing \$SSHHOME/.sshrc.d
  --bin               Copy this sshrc script to the remote host
  --debug[=LEVEL]     Print out debug info
                      LEVEL 1 prints the SSHRC_CMD
                      LEVEL 2 prints the uncompressed bootstrap script
  -h, --help          Display this help message and exit

SSH_ARGS:
  See ssh(1)
EOF
}

# Use openssl or base64
encoder() {
  if  [ "$(command -v openssl)" ]; then openssl enc -base64 "$@"
  elif [ "$(command -v base64)" ]; then base64 "$@"
  else return 1
  fi
}

# Remove empty lines and full line comments
minify() {
  sed '/^\s*$/d; /^\s*#[^!]/d'
}

# Some shells (both locally and on the remote server) will complain if a
# command is too large. Check to see if sshrc_cmd will exceed arg_max (default
# to 64kb)
check_size() {
  local LC_ALL=C size="${#1}"

  if [[ "${show_size}" == "true" ]]; then
    echo "${size} bytes"
    exit 0
  fi

  [[ "${arg_max:=$(( 65 * 1024 ))}" == 0 ]] && return
  if [[ "${size}" -gt "${arg_max}" ]]; then
    echo >&2 "Error: the compressed size of .sshrc, .sshrc.d, and the sshrc" \
      "bootstrap script is greater than 64kb"
    echo >&2 "Current size: ${size} bytes"
    exit 1
  fi
}

set_sshrc_cmd() {
  local files bootstrap

  if [[ -f "${SSHHOME}/.sshrc" ]]; then
    files="${files} .sshrc"
  else
    echo >&2 "Error: could not find .sshrc in current directory or ${HOME}"
    exit 1
  fi
  [[ -d "${SSHHOME}/.sshrc.d" ]] && files="${files} .sshrc.d"

  bootstrap="
  # Create SSHHOME, copy .sshrc and .sshrc.d, and clean up when leaving
  export SSHHOME=\$(mktemp -d -t .$(whoami).sshrc.XXXXXXXX)
  export SSHRCCLEANUP=\$SSHHOME
  trap \"rm -rf \$SSHRCCLEANUP; exit\" 0
  echo $'$(tar c -h -C "${SSHHOME}" ${files} | encoder)' \
    | encoder -d \
    | tar mx -C \$SSHHOME
  mkdir -p \$SSHHOME/.sshrc.d

  # Optionally copy sshrc binary, so we can run sshrc again from the new host
  $(
  if [[ "${bin}" == "true" ]]; then
    echo "
    echo $'$(minify < "$0" | encoder)' \
      | encoder -d > \$SSHHOME/sshrc
    chmod +x \$SSHHOME/sshrc"
  fi
  )

  # Start shell using .sshrc.d/sh if it exists; otherwise create a wrapper
  # around bash
  $(
  if [[ ! -e "${SSHHOME}/.sshrc.d/sh" ]]; then
    echo "
    echo '#!/usr/bin/env bash
    exec bash --rcfile <(echo \"
    # Simulate a login shell
    [[ -r /etc/profile ]] && source /etc/profile
    for file in \$HOME/{.bash_profile,.bash_login,.profile}; do
      [[ -r \\\"\$file\\\" ]] && source \$file
    done
    export PATH=\$PATH:\$SSHHOME
    source \$SSHHOME/.sshrc
    \") \"\$@\"' > \$SSHHOME/.sshrc.d/sh"
  fi
  )
  chmod +x \$SSHHOME/.sshrc.d/sh

  # Optionally hide welcome messages
  $(
  if [[ "$#" -le 1 && "${hushlogin}" != "true" ]]; then
    echo "
    if [ ! -e \"\$HOME/.hushlogin\" ]; then
      if [ -e /etc/motd ]; then
        cat /etc/motd
      elif [ -e /etc/update-motd.d ]; then
        run-parts /etc/update-motd.d/ 2>/dev/null
      fi
    fi"
  fi
  )

  # Start the shell
  \$SSHHOME/.sshrc.d/sh $([[ "$#" -gt 1 ]] && echo "-c \"$*\"")"

  if [[ "${debug}" == 2 ]]; then
    echo "${bootstrap}" | minify
    exit 0
  fi

  # This is the remote command that sshrc passes to ssh. It is comprised of the
  # compressed sshrc bootstrap script and the commands needed to decompress and
  # run it. The .sshrc config file and files within .sshrc.d are embedded
  # within the bootstrap script.
  sshrc_cmd="$(echo "
  # Bail if neither openssl nor base64 is installed on the remote host
  if [ ! \$(command -v openssl) -a ! \$(command -v base64) ]; then
    echo >&2 \"Error: sshrc requires openssl or base64 to be installed \" \\
      \"on the server\"
    exit 1
  fi
  $(declare -f encoder)

  # Compress bootstrap script for faster initial ssh connection and reduced
  # risk of hitting command buffer length limit
  eval \"\$(
  echo $'$(echo "${bootstrap}" | "${archiver}" -c -9 | encoder)' \
    | encoder -d \
    | ${archiver} -d
  )\"" | minify)"

  if [[ "${debug}" == 1 ]]; then
    echo "${sshrc_cmd}"
    exit 0
  fi
}

main() {
  local ssh_args host sshrc_cmd cmd size \
    hushlogin arg_max show_size bin debug archiver
  archiver=bzip2
  [[ -e "${SSHHOME}/.sshrc.d/.hushlogin" ]] && hushlogin="true"
  while getopts ":h-:b:c:D:E:e:F:I:i:J:L:l:m:O:o:p:Q:R:S:W:w:" opt; do
    case "${opt}" in
      -)
        case "${OPTARG}" in
          help)
            show_help
            exit 0
            ;;
          archiver)
            archiver="${!OPTIND}"
            OPTIND=$(( OPTIND + 1 ))
            ;;
          archiver=*)
            archiver="${OPTARG#*=}"
            ;;
          arg-max)
            arg_max="${!OPTIND}"
            OPTIND=$(( OPTIND + 1 ))
            ;;
          arg-max=*)
            arg_max="${OPTARG#*=}"
            ;;
          hushlogin)
            hushlogin="true"
            ;;
          arg-size)
            show_size="true"
            ;;
          bin)
            bin="true"
            ;;
          debug)
            debug=1
            ;;
          debug=*)
            debug="${OPTARG#*=}"
            ;;
          *)
            if [ "$OPTERR" = 1 ]; then
              echo >&2 "Invalid option --${OPTARG}"
              show_help
            fi
            exit 1
            ;;
        esac;;
      b|c|D|E|e|F|I|i|J|L|l|m|O|o|p|Q|R|S|W|w)
        ssh_args="${ssh_args} -${opt} -${OPTARG}"
        ;;
      h)
        show_help
        exit 0
        ;;
      *)
        ssh_args="${ssh_args} -${OPTARG}"
        ;;
    esac
  done
  shift $((OPTIND-1))
  host="$1"
  shift
  cmd="$*"

  if [[ ! $(command -v openssl) && ! $(command -v base64) ]]; then
    echo >&2 "Error: sshrc requires openssl or base64 to be installed locally"
    exit 1
  fi

  if [[ -z "${SSHHOME}" ]]; then
    for SSHHOME in $PWD $HOME; do
      [[ -f "${SSHHOME}/.sshrc" ]] && break
    done
  fi

  set_sshrc_cmd "$cmd"
  check_size "${sshrc_cmd}"

  ssh -t ${ssh_args} "${host}" "${sshrc_cmd}"
}

main "$@"
