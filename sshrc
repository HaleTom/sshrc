#!/usr/bin/env bash

show_help() {
cat >&2 <<EOF
Usage: sshrc [OPTIONS] [SSH_ARGS...]

Options:
  --arg-max=BYTES   Ensure SSHRC_CMD is less than BYTES in size
                    Default is 65536 (64kb); set to 0 to disable this check
  --arg-size        Print the compressed size of SSHRC_CMD in bytes and exit
  --hushlogin       Supress any motd welcome message
                    This can also be accomplished by creating a .hushlogin
                    file ing \$SSHHOME/.sshrc.d
  -h, --help        Display this help message and exit

SSH_ARGS:
  See ssh(1)
EOF
}

encode() {
  # Use openssl or base64
  if  [ "$(command -v openssl)" ]; then openssl enc -base64 "$@"
  elif [ "$(command -v base64)" ]; then base64 "$@"
  fi
}

minify() {
  # Remove empty lines and full line comments
  echo "$1"| sed '/^\s*$/d; /^\s*#[^!]/d'
}

check_size() {
  # Some shells (both locally and on the remote server) will complain if a
  # command is too large. Check to see if sshrc_cmd will exceed arg_max
  # (default to 64kb)

  local LC_ALL=C size="${#1}"

  if [[ "${show_size}" == "true" ]]; then
    echo "${size} bytes"
    exit 0
  fi

  [[ "${arg_max:=$(( 65 * 1024 ))}" == 0 ]] && return
  if [[ "${size}" -gt "${arg_max}" ]]; then
    echo >&2 "Error: the compressed size of .sshrc, .sshrc.d, and the sshrc" \
      "bootstrap script is greater than 64kb"
    echo >&2 "Current size: ${size} bytes"
    exit 1
  fi
}

sshrc_cmd() {
  # This is the remote command that sshrc passes to ssh. It is comprised of the
  # compressed sshrc bootstrap script and the commands needed to decompress and
  # run it. The .sshrc config file and files within .sshrc.d are embedded
  # within the bootstrap script.

  local files welcome rc bootstrap

  if [[ -f "${SSHHOME}/.sshrc" ]]; then
    files="${files} .sshrc"
  else
    echo >&2 "Error: could not find .sshrc in current directory or ${HOME}"
    exit 1
  fi
  [[ -d "${SSHHOME}/.sshrc.d" ]] && files="${files} .sshrc.d"

  if [[ "$#" -le 1 && "${hushlogin}" == "false" ]]; then
    welcome="[ ! -e \"\$HOME/.hushlogin\" -a -e /etc/motd ] && cat /etc/motd"
  else
    welcome=""
  fi

  rc="
  [[ -r /etc/profile ]] && source /etc/profile
  if [[ -r ~/.bash_profile ]]; then
    source ~/.bash_profile
  elif [[ -r ~/.bash_login ]]; then
    source ~/.bash_login
  elif [[ -r ~/.profile ]]; then
    source ~/.profile
  fi
  export PATH=\$PATH:\$SSHHOME
  source \$SSHHOME/.sshrc"

  bootstrap="
  # Create SSHHOME, copy .sshrc and .sshrc.d, and clean up when leaving
  export SSHHOME=\$(mktemp -d -t .$(whoami).sshrc.XXXXXXXX)
  export SSHRCCLEANUP=\$SSHHOME
  trap \"rm -rf \$SSHRCCLEANUP; exit\" 0
  echo $'$(tar c -h -C "${SSHHOME}" ${files} | openssl enc -base64)' \
    | openssl enc -base64 -d \
    | tar mx -C \$SSHHOME

  # Copy sshrc binary, so we can run sshrc again from the new host
  echo $'$(minify "$(cat "$0")" | openssl enc -base64)' \
    | openssl enc -base64 -d > \$SSHHOME/sshrc
  chmod +x \$SSHHOME/sshrc

  # Create a wrapper around bash and use that as the shell
  echo 'bash --rcfile <(echo \"${rc}\") \"\$@\"' > \$SSHHOME/sshrcsh
  chmod +x \$SSHHOME/sshrcsh
  SHELL=\$SSHHOME/sshrcsh
  $welcome
  \$SSHHOME/sshrcsh $([[ "$#" -gt 1 ]] && echo "-c \"$*\"")"

  minify "
  # Bail if openssl isn't installed on the remote host
  $(declare -f encode)
  if [ ! \$(command -v encode) ]; then
    echo >&2 \"Error: sshrc requires openssl or base64 to be installed \" \\
      \"on the server\"
    exit 1
  fi

  # Compress bootstrap script for faster initial ssh connection and reduced
  # risk of hitting command buffer length limit
  eval \"\$(echo $'$(echo "${bootstrap}" | gzip -c | openssl enc -base64)' \
    | openssl enc -base64 -d \
    | gzip -d)\""
}

main() {
  local ssh_args host sshrc_cmd cmd size hushlogin arg_max show_size
  hushlogin="false"
  [[ -e "${SSHHOME}/.sshrc.d/.hushlogin" ]] && hushlogin="true"
  while getopts ":h-:b:c:D:E:e:F:I:i:J:L:l:m:O:o:p:Q:R:S:W:w:" opt; do
    case "${opt}" in
      -)
        case "${OPTARG}" in
          help)
            show_help
            exit 0
            ;;
          arg-max)
            arg_max="${!OPTIND}"
            OPTIND=$(( OPTIND + 1 ))
            ;;
          arg-max=*)
            arg_max="${OPTARG#*=}"
            ;;
          hushlogin)
            hushlogin="true"
            ;;
          arg-size)
            show_size="true"
            ;;
          *)
            if [ "$OPTERR" = 1 ]; then
              echo "Invalid option --${OPTARG}" >&2
            fi
            ;;
        esac;;
      b|c|D|E|e|F|I|i|J|L|l|m|O|o|p|Q|R|S|W|w)
        ssh_args="${ssh_args} -${opt} -${OPTARG}"
        ;;
      h)
        show_help
        exit 0
        ;;
      *)
        ssh_args="${ssh_args} -${OPTARG}"
        ;;
    esac
  done
  shift $((OPTIND-1))
  host="$1"
  shift
  cmd="$*"

  if [[ ! $(command -v encode) ]]; then
    echo >&2 "Error: sshrc requires openssl or base64 to be installed locally"
    exit 1
  fi

  if [[ -z "${SSHHOME}" ]]; then
    for SSHHOME in $PWD $HOME; do
      [[ -f "${SSHHOME}/.sshrc" ]] && break
    done
  fi

  sshrc_cmd="$(sshrc_cmd "$cmd")"
  check_size "${sshrc_cmd}"

  ssh -t ${ssh_args} "${host}" "${sshrc_cmd}"
}

main "$@"
