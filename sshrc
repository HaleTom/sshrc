#!/usr/bin/env bash

show_help() {
cat >&2 <<EOF
Usage: sshrc [OPTIONS] [SSH_ARGS...]

Options:
  --archiver=UTILITY  Use UTILITY for compression
                      Default is bzip2; gzip and xz are also supported
  --arg-max=BYTES     Ensure SSHRC_CMD is less than BYTES in size
                      Default is 65536 (64kb); set to 0 to disable this check
  --arg-size          Print the compressed size of SSHRC_CMD in bytes and exit
  --hushlogin         Supress motd welcome messages
                      This can also be accomplished by creating a .hushlogin
                      file ing \$SSHHOME/.sshrc.d
  --bin               Copy this sshrc script to the remote host
  --debug[=LEVEL]     Print out debug info
                      LEVEL 1 prints the SSHRC_CMD
                      LEVEL 2 prints the uncompressed bootstrap script
  -h, --help          Display this help message and exit

SSH_ARGS:
  See ssh(1)
EOF
}

# Use openssl or base64
encoder() {
  if  [ "$(command -v openssl)" ]; then echo "openssl enc -base64 $*"
  elif [ "$(command -v base64)" ]; then echo "base64 $*"
  fi
}

# Remove empty lines and full line comments
minify() {
  sed '/^\s*$/d; /^\s*#[^!]/d'
}

# Some shells (both locally and on the remote server) will complain if a
# command is too large. Check to see if sshrc_cmd will exceed arg_max (default
# to 64kb)
check_size() {
  local LC_ALL=C size="${#1}"

  if [[ "${show_size}" == "true" ]]; then
    echo "${size} bytes"
    exit 0
  fi

  [[ "${arg_max:=$(( 65 * 1024 ))}" == 0 ]] && return
  if [[ "${size}" -gt "${arg_max}" ]]; then
    echo >&2 "Error: the compressed size of .sshrc, .sshrc.d, and the sshrc" \
      "bootstrap script is greater than 64kb"
    echo >&2 "Current size: ${size} bytes"
    exit 1
  fi
}

set_sshrc_cmd() {
  local files welcome rc bootstrap binary

  if [[ -f "${SSHHOME}/.sshrc" ]]; then
    files="${files} .sshrc"
  else
    echo >&2 "Error: could not find .sshrc in current directory or ${HOME}"
    exit 1
  fi
  [[ -d "${SSHHOME}/.sshrc.d" ]] && files="${files} .sshrc.d"

  # Optionally hide welcome messages
  if [[ "$#" -le 1 && "${hushlogin}" != "true" ]]; then
    welcome="[ ! -e \"\$HOME/.hushlogin\" -a -e /etc/motd ] && cat /etc/motd"
  fi

  rc="
  [[ -r /etc/profile ]] && source /etc/profile
  if [[ -r ~/.bash_profile ]]; then
    source ~/.bash_profile
  elif [[ -r ~/.bash_login ]]; then
    source ~/.bash_login
  elif [[ -r ~/.profile ]]; then
    source ~/.profile
  fi
  export PATH=\$PATH:\$SSHHOME
  source \$SSHHOME/.sshrc"

  # Optionally copy sshrc binary, so we can run sshrc again from the new host
  if [[ "${bin}" == "true" ]]; then
    binary="
    echo $'$(minify < "$0" | $(encoder))' \
      | \$(encoder -d) > \$SSHHOME/sshrc
    chmod +x \$SSHHOME/sshrc
    "
  fi

  bootstrap="
  # Create SSHHOME, copy .sshrc and .sshrc.d, and clean up when leaving
  export SSHHOME=\$(mktemp -d -t .$(whoami).sshrc.XXXXXXXX)
  export SSHRCCLEANUP=\$SSHHOME
  trap \"rm -rf \$SSHRCCLEANUP; exit\" 0
  echo $'$(tar c -h -C "${SSHHOME}" ${files} | $(encoder))' \
    | \$(encoder -d) \
    | tar mx -C \$SSHHOME
  ${binary}

  # Create a wrapper around bash and use that as the shell
  echo 'bash --rcfile <(echo \"${rc}\") \"\$@\"' > \$SSHHOME/sshrcsh
  chmod +x \$SSHHOME/sshrcsh

  # Start the shell
  ${welcome}
  \$SSHHOME/sshrcsh $([[ "$#" -gt 1 ]] && echo "-c \"$*\"")"

  if [[ "${debug}" == 2 ]]; then
    echo "${bootstrap}" | minify
    exit 0
  fi

  # This is the remote command that sshrc passes to ssh. It is comprised of the
  # compressed sshrc bootstrap script and the commands needed to decompress and
  # run it. The .sshrc config file and files within .sshrc.d are embedded
  # within the bootstrap script.
  sshrc_cmd="$(echo "
  # Bail if openssl isn't installed on the remote host
  $(declare -f encoder)
  if [ -z \"\$(encoder)\" ]; then
    echo >&2 \"Error: sshrc requires openssl or base64 to be installed \" \\
      \"on the server\"
    exit 1
  fi

  # Compress bootstrap script for faster initial ssh connection and reduced
  # risk of hitting command buffer length limit
  eval \"\$(echo $'$(echo "${bootstrap}" | "${archiver}" -c -9 | $(encoder))' \
    | \$(encoder -d) \
    | ${archiver} -d)\"" | minify)"

  if [[ "${debug}" == 1 ]]; then
    echo "${sshrc_cmd}"
    exit 0
  fi
}

main() {
  local ssh_args host sshrc_cmd cmd size \
    hushlogin arg_max show_size bin debug archiver
  archiver=bzip2
  [[ -e "${SSHHOME}/.sshrc.d/.hushlogin" ]] && hushlogin="true"
  while getopts ":h-:b:c:D:E:e:F:I:i:J:L:l:m:O:o:p:Q:R:S:W:w:" opt; do
    case "${opt}" in
      -)
        case "${OPTARG}" in
          help)
            show_help
            exit 0
            ;;
          archiver)
            archiver="${!OPTIND}"
            OPTIND=$(( OPTIND + 1 ))
            ;;
          archiver=*)
            archiver="${OPTARG#*=}"
            ;;
          arg-max)
            arg_max="${!OPTIND}"
            OPTIND=$(( OPTIND + 1 ))
            ;;
          arg-max=*)
            arg_max="${OPTARG#*=}"
            ;;
          hushlogin)
            hushlogin="true"
            ;;
          arg-size)
            show_size="true"
            ;;
          bin)
            bin="true"
            ;;
          debug)
            debug=1
            ;;
          debug=*)
            debug="${OPTARG#*=}"
            ;;
          *)
            if [ "$OPTERR" = 1 ]; then
              echo >&2 "Invalid option --${OPTARG}"
              show_help
            fi
            exit 1
            ;;
        esac;;
      b|c|D|E|e|F|I|i|J|L|l|m|O|o|p|Q|R|S|W|w)
        ssh_args="${ssh_args} -${opt} -${OPTARG}"
        ;;
      h)
        show_help
        exit 0
        ;;
      *)
        ssh_args="${ssh_args} -${OPTARG}"
        ;;
    esac
  done
  shift $((OPTIND-1))
  host="$1"
  shift
  cmd="$*"

  if [[ -z "$(encoder)" ]]; then
    echo >&2 "Error: sshrc requires openssl or base64 to be installed locally"
    exit 1
  fi

  if [[ -z "${SSHHOME}" ]]; then
    for SSHHOME in $PWD $HOME; do
      [[ -f "${SSHHOME}/.sshrc" ]] && break
    done
  fi

  set_sshrc_cmd "$cmd"
  check_size "${sshrc_cmd}"

  ssh -t ${ssh_args} "${host}" "${sshrc_cmd}"
}

main "$@"
